### Hashing 이란?

해싱은 암호화 해시 함수와 같이 알려진 수학적 함수를 사용하여 주어진 메시지를 스트링이나 해시로 생성하는 처리이다.

여러 해시 기능이 있지만 해싱 암호에 맞게 조정 된 기능은 보안을 유지하기 위해 4가지 주요  속성을 가져야한다.

1. 동일한 해시 함수에 의해 처리된 메시지는 항상 동일한 해시를 생성해야 한다.
2. 해시에서 메시지로 되돌릴수 없어야 한다.
3. 메시지를 조금만 변경해도 많이 달라진 해시가 생성된다.
4. 서로 다른 메시지가 같은 해시를 만들어서는 안된다.

그리고 암호 해싱 기능은 느려야 한다. 빠른 알고리즘은 해커가 부르트 brute force를 사용하여 암호를 알아낼 가능성이 있다.
이런 모든 기준을 충족하는 해시함수는 ```PBKDF2```, ```BCrypt```, ```SCrypt```가 있다.

### 단방향 해시 함수
단방향 해시 함수는 수학적인 연산을 통해 원본 메시지를 변환하여 암호화된 메시지인 다이제스트를 생성한다.
원본 베시지를 알면 암호화된 메시지를 구하기는 쉽지만 암호화된 메시지로는 원본 메시지를 구할 수 없어야 하며 이를 단방향성이라고 한다.
대부분의 해시 함수는 입력 값의 일부가 변경되었을 때 다이제스트가 완전히 달라지도록 설계되어 있다.
이 특징을 avalanche 효과라고 하며, 사용자의 원본 패스워드를 추론하기 어렵게 만드는 중요한 요소이다. 하지만 이것만으로는 패스워드 보안이 충분히 안전하다고 말할 수 없다.

#### 단방향 해시의 문제점
SHA-256과 같은 해시 함수를 사용해 패스워드를 암호화해 저장하고 값을 비교하는 것만으로 충분한 암호화 메커니즘을 적용했다고 생각하지만, 실제로는 다음과 같은 두 가지 문제점이 있다.

1. 인식 가능성(recognizability)
동일한 메시지가 언제나 동일한 다이제스트를 갖는다면, 공격자가 전처리된 다이제스트를 가능한 한 많이 확보한 다음 이를 탈취한 다이제스트와 비교해 원본 메시지를 찾아내거나
동일한 효과의 메시지를 찾을 수 있다. 이와 같은 다이제스트 목록을 레인보우 테이블(rainbow table)이라 하고, 이와 같은 공격 방식을 레인보우 공격(rainbow attack)이라 한다.
게다가 다른 사용자의 패스워드가 같으면 다이제스트도 같으므로 한꺼번에 정보가 탈취될 수 있다.

2. 속도(speed)
해시 함수는 암호학에서 널리 사용되지만 원래 패스워드를 저장하기 위해서 설계된 것이 아니라 짧은 시간에 데이터를 검색하기 위해 설계된 것이다.
바로 여기서 문제가 발생한다. 해시 함수의 빠른 처리 속도로 인해 공격자는 매우 빠른 속도로 임의의 문자열의 다이제스트와 해킹할 대상의 다이제스트를 비교할 수 있다.
(MD5를 사용한 경우 일반적인 장비를 이용하여 1초당 56억 개의 다이제스트를 대입할 수 있다.)
   

#### 단방향 해시 함수 보완하기
솔팅 (Salting)
솔트(salt)는 단방향 해시 함수에서 다이제스트를 생성할 때 추가되는 바이트 단위의 임의의 문자열이다. 
그리고 이 원본 메시지에 문자열을 추가하여 다이제스를 생성하는 것을 솔팅(salting)이라 한다.
솔트와 패스워드의 다이제스트를 데이터베이스에 저장하고, 사용자가 로그인할 때 입력한 패스워드를 해시하여 일치 여부를 확인할 수 있다. 
이 방법을 사용할 때에는 모든 패스워드가 고유의 솔트를 갖고 솔트의 길이는 32바이트 이상이어야 솔트와 다이제스트를 추측하기 어렵다.

키 스트레칭(key stretching)
입력한 패스워드의 다이제스트를 생성하고, 생성된 다이제스트를 입력 값으로 하여 다이제스트를 생성하고, 또 이를 반복하는 방법으로 다이제스트를 생성할 수도 있다. 
이렇게 하면 입력한 패스워드를 동일한 횟수만큼 해시해야만 입력한 패스워드의 일치 여부를 확인할 수 있다. 이것이 기본적인 키 스트레칭 과정이다.

#### Adaptive Key Derivation Functions
adaptive key derivation function은 다이제스트를 생성할 때 솔팅과 키 스트레칭을 반복하며 솔트와 패스워드 외에도 입력 값을 추가하여 공격자가 쉽게 다이제스트를 유추할 수 없도록 하고 보안의 강도를 선택할 수 있다.
이 함수들은 GPU와 같은 장비를 이용한 병렬화를 어렵게 하는 기능을 제공한다. 이와 같은 기능은 프로그램이 언어에서 제공하는 라이브러리만으로는 구현하기 어렵다.

##### PBKDF2
가장 많이 사용되는 key derivation function은 PBKDF2(Password-Based Key Derivation Function)이다. 
해시 함수의 컨테이너인 PBKDF2는 솔트를 적용한 후 해시 함수의 반복 횟수를 임의로 선택할 수 있다. 
PBKDF2는 아주 가볍고 구현하기 쉬우며, SHA와 같이 검증된 해시 함수만을 사용한다.

##### bcrypt
bcrypt는 애초부터 패스워드 저장을 목적으로 설계되었다. Niels Provos와 David Mazières가 1999년 발표했고 현재까지 사용되는 가장 강력한 해시 메커니즘 중 하나이다.
bcrypt는 보안에 집착하기로 유명한 OpenBSD에서 기본 암호 인증 메커니즘으로 사용되고 있고 미래에 PBKDF2보다 더 경쟁력이 있다고 여겨진다.
bcrypt에서 "work factor" 인자는 하나의 해시 다이제스트를 생성하는 데 얼마만큼의 처리 과정을 수행할지 결정한다.
"work factor"를 조정하는 것만으로 간단하게 시스템의 보안성을 높일 수 있다.
다만 PBKDF2나 scrypt와는 달리 bcrypt는 입력 값으로 72 bytes character를 사용해야 하는 제약이 있다.

##### scrypt
scrypt는 다이제스트를 생성할 때 메모리 오버헤드를 갖도록 설계되어, 억지 기법 공격(brute-force attack)을 시도할 때 병렬화 처리가 매우 어렵다. 
따라서 PBKDF2보다 안전하다고 평가되며 미래에 bcrypt에 비해 더 경쟁력이 있다고 여겨진다. scrypt는 보안에 아주 민감한 사용자들을 위한 백업 솔루션을 제공하는 Tarsnap에서도 사용하고 있다. 
또한 scrypt는 여러 프로그래밍 언어의 라이브러리로 제공받을 수 있다.

### ref
 - [Hashing a Password in Java](https://www.baeldung.com/java-password-hashing)
 - [안전한 패스워드 저장](https://d2.naver.com/helloworld/318732)